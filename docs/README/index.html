<h1>Email OTPs</h1>
<p>This is an <strong>early</strong> exporation of mechanisms to facilitade the verification of email addresses on the Web.</p>
<p>It is largely based on the somewhat analogous mechanisms explored in origin-bound <a href="https://github.com/WICG/sms-one-time-codes">SMS OTPs</a> and <a href="https://github.com/WICG/web-otp">WebOTP</a>.</p>
<h1>A Baseline</h1>
<p>As starting point, we are imagining that there is maybe a convention that websites could use cooperatively with email providers to facilitate the verification of email addresses (note, we make two big assumptions here: (a) that the email has already been previously acquired by the website and (b) that the incentives are aligned for a cooperative relationship).</p>
<p>In the first pass, a website uses a newly exposed browser API to declare that it is expecting an email OTP:</p>
<pre><code class="language-html">&lt;input autocomplete=&quot;one-time-code&quot;&gt;
</code></pre>
<p>Or imperatively:</p>
<pre><code class="language-javascript">navigator.credentials.get({
  otp: { transport: [&quot;email&quot;] }
});
</code></pre>
<p>It then sends an email to the email provider with an agreed upon convention. It is unclear exactly what that convention is, but just as a starting point, take something as simple as a reserved email header:</p>
<pre><code>X-Email-OTP: @example.com #1234
</code></pre>
<p>For example:</p>
<pre><code class="language-mime">MIME-Version: 1.0
Content-Type:  multipart/mixed;  boundary=frontier
From: Relying Party &lt;no-reply@rp.com&gt;
To: user@email.com
Subject: Verify Email Address
X-Email-OTP: @example.com #1234
...
</code></pre>
<p>This special convention instructs the cooperative email client to inform (with the user's agreement) the browser of its arrival.</p>
<p>For native email clients (e.g. android/ios apps), the mechanism to inform the browser will probably vary from browser to browser.</p>
<p>For web email clients, however, we could probably expose a Web API that allows the email client to inform the browser of the arrival. For example:</p>
<pre><code class="language-javascript">navigator.credentials.store({
  otp: {
    audience: &quot;https://example.com&quot;,
    transport: &quot;email&quot;,
    value: &quot;1234&quot;
  }
});
</code></pre>
<p>One of the key benefits about this baseline is that it is imposes no changes in user behavior, fitting complementary with the existing norms for email verification. By that we mean that it is strictly additive: it degrades gracefully to the current norm when it isn't available / fails (e.g. the email header is invisible) but offers an uplift in conversion rates when it succeeds (e.g. automates part of the flow that is done manually).</p>
<h1>An Extension</h1>
<p>One of the clear problems with this baseline is that it still relies on email delivery to perform email verification. That's clearly a problem because:</p>
<ul>
<li>email delivery is slow (say, order of minutes in the 50th percentile)</li>
<li>email delivery is unreliable (e.g. spam filters)</li>
<li>the email service gets to learn what website you are logging in to</li>
</ul>
<p>So, one of the ways this baseline can be extended is to make email verification without dependending on actually sending/receiving emails.</p>
<p>The first thought that occurred to us, was something along the lines of public/private key signing.</p>
<p>In this formulation, websites would still use the same consumer APIs and would still also send emails with headers. A browser would still wait for a companion <code>navigator.credentials.store()</code> call to be made, but, in <strong>addition</strong> to that, the consumer API would also take:</p>
<ul>
<li>an email address that is expecting to be verified.</li>
<li>a non-guessable nonce</li>
</ul>
<p>For example:</p>
<pre><code class="language-javascript">navigator.credentials.get({
  otp: {
    transport: [&quot;email&quot;],
    email: &quot;user@email.com&quot;,
    nonce: &quot;123&quot;
  }
});
</code></pre>
<p>The browser would then reach out to the email provider to check if:</p>
<ul>
<li>the user is logged in and the email to be verified matches the logged in user</li>
<li>it supports a faster way to make email verification.</li>
</ul>
<p>It is unclear exactly how that would be done, but just a starting point, lets pretend, by convention, there would be a credentialed .well-known file somewhere that email providers expose:</p>
<pre><code class="language-http">GET /.well-known/email-otp.json HTTP/1.1
Host: email.com
Cookie: 123
</code></pre>
<p>With the <code>cookie</code> that is passed, the session is established, and if there is a valid user at the other end it responds to the browser:</p>
<pre><code class="language-http">HTTP/1.1 200 OK
Date: Mon, 27 Jul 2009 12:28:53 GMT
Last-Modified: Wed, 22 Jul 2009 19:15:56 GMT
Content-Length: 88
Content-Type: text/json
{
  email: &quot;user@email.com&quot;,
  verification: &quot;/verify.php&quot;
}
</code></pre>
<p>If a matching email user is available and it affords to be verified, the browser gets the user permission and makes a POST request to the verification endpoint with the <strong>nonce</strong> as a parameter:</p>
<pre><code class="language-http">POST /verify.php HTTP/1.1
Host: email.com
Content-Type: application/x-www-form-urlencoded
Cookie: 123
nonce=123
</code></pre>
<p>The email service then mints and signs a token that proves to the website that the current user (identified by the cookie) actually does own the email in question.</p>
<p>It is unclear exactly how that would be done, but just as a starting point, take something like a JWT:</p>
<pre><code class="language-http">HTTP/1.1 200 OK
Date: Mon, 27 Jul 2009 12:28:53 GMT
Last-Modified: Wed, 22 Jul 2009 19:15:56 GMT
Content-Length: 88
Content-Type: application/jwt
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhdWRpZW5jZSI6IjEyMzQiLCJlbWFpbCI6InVzZXJAZW1haWwuY29tIiwiZXhwIjoxNTE2MjM5MDIyLCJpYXQiOjE1MTYyMzkwMjJ9.6AZ4WxvdJvjU8LtOxRoH33F4gEV-MwosvoyRADXhiyM
</code></pre>
<p>This is a base64 encoded signed token. The payload binds the email address to the specific &quot;nonce&quot; passed initially for a short period of time (e.g. sets expiration times).</p>
<pre><code class="language-json">{
  &quot;iss&quot;: &quot;https://email.com&quot;,
  &quot;aud&quot;: &quot;1234&quot;,
  &quot;sub&quot;: &quot;user@email.com&quot;,
  &quot;exp&quot;: 1516239022,
  &quot;iat&quot;: 1516239022
}
</code></pre>
<p>The browser would take this base64 encoded JWT and pass it back as a result to the <code>navigator.credentials.get()</code> call.</p>
<p>In possession of the JWT, the website can use the existing JWT conventions for checking its validity and provenance (e.g. getting public keys from the <a href="https://tools.ietf.org/html/rfc7517">JWKS</a> <code>/.well-known/jwks.json</code>), and hence the proof of the user's possession of the email address.</p>
<p>This extension is notably more complicated for browsers and email vendors to implement, but is notably:</p>
<ul>
<li>faster and more reliable than the baseline and, importantly,</li>
<li>backwards compatible with user norms like the baseline</li>
<li>not-mutually exclusive to the baseline</li>
</ul>
<p>Because there are few email providers and even fewer browser vendors, it seems like the right place to push complexity to, if it leads to higher conversion rates to a large user base.</p>
<p>Importantly, because it can be used <strong>in addition to</strong> the baseline (which, in an on itself is also <strong>additive to</strong> the status quo), this extension could be used by sophisticated email providers and ignored by smaller ones.</p>
